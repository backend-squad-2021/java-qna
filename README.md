# 질문답변 게시판

## heroku 배포 주소

[ellie-qna-app](https://ellie-qna-app.herokuapp.com/)

## 1단계
 
### 구현한 기능 
 
- 회원가입 
- 회원 목록 보기  
- 회원 프로필 
- 질문하기
- 질문 목록 보기 
- 회원 정보 수정 

## 2단계 

### 구현한 기능 

- H2 데이터베이스에 대한 의존관계 설정 및 설정
- 회원 정보 데이터 데이터베이스에 저장하고 조회함
- 질문 데이터 데이터베이스에 저장하고 조회함
 

## 3단계 

### 구현한 기능 

- 로그인 기능 
- 로그인 상태에 따른 메뉴 처리 및 로그아웃 
- 로그인했을 때만 질문을 생성할 수 있도록 함 
- 질문 수정하기 
- 질문 삭제하기 
- 댓글 생성하기
- 댓글 수정하기
- 댓글 삭제하기 
- 테스트 데이터 추가하기(테스트 데이터는 올리지 말아야 하는 건가?)

### 아쉬운 점 

#### 댓글 수정하기 기능

- 댓글 수정하기에서 수정할 답변을 작성한 후 수정하기 버튼을 눌렀을 때 수정 권한을 체크한다.
- 처음에 댓글 수정하기를 눌렀을 때 권한을 체크하고 싶었는데 하지 못했다. 수정하기를 누르고 새로운 페이지가 나오는 것이 아니라
  한 화면에서 수정 폼이 생겨서 수정하기 떄문에 get 요청으로 처음에 체크할 수 없었다. 어떻게 하면 좋을지 생각해봐야 겠다!  

#### 잘못된 접근을 했을 때 처리하기

- 지금은 로그인을 안했으면 로그인 화면으로 이동함(로그인 후 전 화면으로 돌아가지 않음) 
- 글을 작성한 사용자가 아닐 경우, 에러를 던지거나, 현재 페이지를 리다이렉트함 
 

#### 로그 활용하기 

step2 로그를 활용하라는 리뷰를 받았는데 아직 못했다. 다음 스텝에서 적용하기!

### 회고 

학습 과정은 
자바지기님 영상을 보고 따라하기 -> 구현한 것을 보고 따라하기 -> 잘 안됨 -> 찾아보기
이 순서대로 하고 있는데 정말 아무것도 몰라서 이렇게만 해도 될지 걱정되지만, 일단은 구현하는 것을 목표로 하기로 했다.
jpa, spring boot가 모든 것을 다 알아서 해주니까 따라하기만 하면 되니까 좋긴 한데, 내가 정확히 무엇을 구현하고 있는지 잘 모르겠다.(??)
 
-----------------

## 4단계 

### 구현한 것 

- 아이디 값을 비교할 때 equals 메서드를 추가하여 값을 비교하도록 수정함 
- 직접 get 메서드로 가져오지 않고 메시지를 보내 반환한 값을 사용하도록 수정함 
- 데이터를 update할 때 null 체크함 
- 데이터를 삭제할 때 완전히 삭제하지 않고 deleted 속성을 true로 수정함 
- query method를 사용하여 데이터를 가져올 때 deleted 속성이 false인 것만 보여줌 
- ExceptionController 를 만들어 에러를 한 곳에서 처리하고 적절한 상태코드를 응답함  
- 요청한 데이터가 없을 경우 에러 페이지로 이동하도록 수정함 


### 아쉬운 점
 
- 삭제, 수정 권한이 없는 사용자에게는 수정, 삭제 버튼이 보이지 않도록 하면 더 좋겠다. 

 
---------------------

## 5단계 

### 공부한 것 

#### ajax요청을 활용란 answer 추가 기능 
answer를 추가하는 ajax 요청하면 응답에 answer 데이터를 주려고 했는데 stackoverflow 에러가 났다. 

에러가 난 이유는 jackson 라이브러리가 반환한 객체를 json 형식으로 바꾸려고 answer객체를 직렬화를 하는데 answer의 question이 `@ManyToOne` 어노테이션을 사용하여 
데이터를 매핑하고 question은 다시 user가 매핑되어 있었기 때문이었다.  
문제가 되는 이유는 answer객체를 직렬화 하려고 하니 question이 있고 다시 이 question을 직렬화 하려고 하니 question에도  user가 있고 다시 이 user를 직렬화 하려고 하니 question이 있고... 
이 과정이 무한 반복해서 스택이 오버플로되기 떄문이다.  

> 직렬화는 데이터 구조 또는 객체 상태를 저장하거나 전송, 재구성할 수 있는 형식으로 변환하는 프로세스이다.  

이를 해결하기 방법을 찾아봤는데 두 가지 방법이 있었다.
하나는 `@JsonIgnore' 어노테이션을 사용하여 이 곳은 json으로 변환하지 않겠다 라고 설정 하기  
다른 하나는 요청이 왔을 때 주고 싶은 것들만 json 형식으로 만들어서 응답해주기 

첫 번째 방법은 매핑한 양쪽 중 어느 하나는 데이터로 넘겨줄 수 없다.  
두 번째는 정의한 모든 데이터를 노출하지 않아도 되고 비즈니스 로직이 추가될 때 마다, View에서 사용하는 데이터를 위해서 코드를 수정하지 않아도 됐다. View 에서만 사용하는 데이터를 분리하여 관리할 수 있다(?)

다른 쪽에 데이터를 넘겨줄 때 이런 데이터를 DTO  객체라고 한다

> DTO(Data transfer object)
>
>프로세스간에 데이터를 운반하는 객체 
>
 
![Dto](https://gmlwjd9405.github.io/images/spring-framework/spring-package-flow.png)
 

하나하나 igonre하여 관리하는 것 보다 필요한 객체만 만들어서 관리하는 것이 더 좋을 것 같아 DTO 객체를 만들어서 반환해주기로 했다! 

#### 이벤트 위임 

답변 수정을 ajax를 활용해 수정하기로 했다.  
수정한 답변을 추가하고 난 답변의 수정 버튼은 리스너가 등록되어 있지 않아서 이벤트를 감지하지 못헀다. 
이 문제를 해결하기 위해 수업자료를 참고해서 상위에 이벤트 리스너를 달아놓고 하위에서 발생한 클릭 이벤트를 감지하도록 하였다.

이벤트 위임은 하위 요소에서 발생하는 이벤트는 더 상위 요소들로 전달되는 특성(버블링)을 이용한 것이다. 
댓글 추가처럼 동적으로 요소가 추가 되었을 때, 100개가 추가되면 그 때 마다 이벤트 리스너를 달아줘야 하기 때문에 관리하기가 어렵다. 
이럴 때 상위에 이벤트 리스너를 달아놓으면 하위에서 발생한 이벤트가 상위로 전달 되다가 이벤트를 잡아서 감지할 수 있게 된다. 

![이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지](https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/)


## 제이쿼리 

댓글 수정하기 하면서 제이쿼리 사용 때문에 시간이 좀 걸렸다. 자바지기님 강의를 듣고 그대로 따라 하려고 하다보니까, 안되는 부분을 찾아보려고 하지 않았다. closest()가 정확히 어디에 있는 것을 
가져오는지 모르고 근처에 있는걸 가져오는 구나! 하면서 사용했었는데... closest는 상위 요소 중에 선택자와 일치하는 첫 번째 요소를 가져오기 때문에 형제 요소는 가져올 수 없었다. 
형제 요소를 가져오기 위해서는 siblings()나 일단 상위 요소를 찾은 다음에 그 안에 있는 요소를 find() 하는 방법이 있었다. 
앞으로는 모르는 게 있으면 문제를 파악하고 찾아봐야겠다.   
